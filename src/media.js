import { addFramePreparer } from './frame-preparers.js';
import { virtualNow, exportDocument } from './shared.js';
import { addElementCreateListener, addElementNSCreateListener } from './create-element.js';
import { virtualSetTimeout } from './timeout-and-interval.js';
import { markAsProcessed, shouldBeProcessed } from './element.js';
const timewebEventDetail = 'timeweb generated';
var mediaList = [];
var currentTimePropertyDescriptor;
export function addMediaNode(node) {
  if (!shouldBeProcessed(node)) {
    return;
  }
  markAsProcessed(node);
  var lastUpdated = virtualNow();
  var precisionTime = node.currentTime * 1000;
  var pendingSeeked;
  var autoplay = node.autoplay;
  var paused = !node.autoplay && node.paused;
  var ended = node.ended;
  node._timeweb_oldPlay = node.play;
  node._timeweb_oldPause = node.pause;
  var media = {
    node: node,
    goToTime: function () {
      var elapsedTime = virtualNow() - lastUpdated;
      var p;
      var playbackRate;
      if (!paused) {
        if (precisionTime / 1000 < node.duration || node.loop) {
          ended = false;
        }
        if (!ended) {
          playbackRate = node.playbackRate;
          precisionTime = precisionTime + (elapsedTime * playbackRate);
          if (node.duration && precisionTime / 1000 > node.duration) {
            if (node.loop) {
              precisionTime -= node.duration * 1000;
            } else {
              precisionTime = node.duration * 1000;
              ended = true;
              node.dispatchEvent(new CustomEvent('ended', { detail: timewebEventDetail }));
            }
          }
          if (playbackRate < 0 && node.duration && precisionTime < 0) {
            // negative playbackRate is not currently supported in Chromium/Chrome,
            // but this is here if it does in the future
            if (node.loop) {
              precisionTime += node.duration * 1000;
            } else {
              precisionTime = 0;
              // should 'ended' be fired here?
            }
          }
          p = new Promise(function (resolve) {
            pendingSeeked = resolve;
          });
          node._timeweb_oldCurrentTime = precisionTime / 1000;
        }
      }
      lastUpdated = virtualNow();
      return p;
    }
  };
  node.addEventListener('seeked', function () {
    if (pendingSeeked) {
      pendingSeeked();
      pendingSeeked = null;
    } else {
      // possibly generated by user or by another program
      lastUpdated = virtualNow();
      precisionTime = node._timeweb_oldCurrentTime * 1000;
    }
  });
  mediaList.push(media);
  node._timeweb_oldPause();
  Object.defineProperty(node, '_timeweb_oldCurrentTime', currentTimePropertyDescriptor);
  Object.defineProperty(node, 'currentTime', {
    get: function () {
      return node._timeweb_oldCurrentTime;
    },
    set: function (time) {
      lastUpdated = virtualNow();
      precisionTime = time * 1000;
      node._timeweb_oldCurrentTime = time;
    }
  });
  Object.defineProperty(node, 'autoplay', {
    get: function () {
      return autoplay;
    },
    set: function (shouldAutoplay) {
      autoplay = shouldAutoplay;
      if (autoplay && paused) {
        lastUpdated = virtualNow();
        paused = false;
        node.dispatchEvent(new CustomEvent('play', { detail: timewebEventDetail }));
      }
    }
  });
  Object.defineProperty(node, 'paused', {
    get: function () {
      return paused;
    }
  });
  Object.defineProperty(node, 'ended', {
    get: function () {
      return ended;
    }
  });
  node.play = function () {
    lastUpdated = virtualNow();
    paused = false;
    node.dispatchEvent(new CustomEvent('play', { detail: timewebEventDetail }));
  };
  node.pause = function () {
    media.goToTime(virtualNow());
    paused = true;
    node.dispatchEvent(new CustomEvent('pause', { detail: timewebEventDetail }));
  };
  node.addEventListener('play', function (e) {
    if (e.isTrusted) {
      media.goToTime();
      paused = false;
      node._timeweb_oldPause();
    } else if (e.detail !== timewebEventDetail) {
      e.stopImmediatePropagation();
    }
  });
  node.addEventListener('pause', function (e) {
    // e.isTrusted checks whether the event is user generated
    if (e.isTrusted) {
      media.goToTime();
      paused = true;
    } else if (e.detail !== timewebEventDetail) {
      e.stopImmediatePropagation();
    }
  });
  if (!paused && !ended) {
    // a 'pause' event may have been unintentionally dispatched
    // before with `node._timeweb_oldPause()`
    // now we'll dispatch a `play` event, which also covers `autoplay` media
    // we'll also use a virtual setTimeout, since in practice
    // the user may be adding a listener afterwards (see issue #1)
    virtualSetTimeout(function () {
      node.dispatchEvent(new CustomEvent('play', { detail: timewebEventDetail }));
    });
  }
}

export function removeMediaNode(node) {
  mediaList = mediaList.filter(function (media) {
    return media.node !== node;
  });
}

// When identifying media nodes, using a MutationObserver covers
// most use cases, since it directly observes the DOM
// The cases it doesn't cover is when elements are not added to DOM
// or significant operations occur on the elements before they are added,
// in which order matters (e.g. `addEventListener`).
// For many of those remaining cases, we'll also overwrite
// document.createElement and document.createElementNS
// There still remains cases where elements are created via other means
// (e.g. through `div.innerHTML`), and then operations are done on them
// before adding them to DOM

// mediaObserver covers elements when they're added to DOM
var mediaObserver = new MutationObserver(function (mutationsList) {
  for (let mutation of mutationsList) {
    if (mutation.type === 'childList') {
      for (let node of mutation.addedNodes) {
        if (node.nodeName === 'VIDEO') {
          addMediaNode(node);
        }
      }
      for (let node of mutation.removedNodes) {
        if (node.nodeName === 'VIDEO') {
          removeMediaNode(node);
        }
      }
    }
  }
});

export function observeMedia() {
  mediaObserver.observe(exportDocument, {
    attributes: false,
    childList: true,
    characterData: false,
    subtree: true
  });
}
// Plugging into createElement and createElementNS covers
// most cases where elements are created programatically.
// mediaObserver will eventually cover them,
// but before then event listeners may be added,
// before e.stopImmediatePropagation can be called
function mediaCreateListener(element, name) {
  var type = name.toLowerCase();
  if (type === 'video' || type.endsWith(':video')) {
    addMediaNode(element);
  }
}


export function initializeMediaHandler() {
  currentTimePropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLMediaElement.prototype, 'currentTime');
  observeMedia();
  addElementCreateListener(mediaCreateListener);
  addElementNSCreateListener(mediaCreateListener);
  addFramePreparer({
    shouldRun: function () {
      return mediaList.length && mediaList.reduce(function (a, b) {
        return a || (!b.paused && !b.ended);
      }, false);
    },
    prepare: function (time) {
      // TODO: maybe optimize this to use callbacks instead of promises
      return Promise.all(mediaList.map(media => media.goToTime(time)));
    }
  });
}
